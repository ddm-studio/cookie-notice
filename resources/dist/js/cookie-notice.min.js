/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/cookie-notice.js":
/*!***************************************!*\
  !*** ./resources/js/cookie-notice.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CookieConsent": function() { return /* binding */ CookieConsent; },
/* harmony export */   "CookieModal": function() { return /* binding */ CookieModal; },
/* harmony export */   "CookieOverlay": function() { return /* binding */ CookieOverlay; }
/* harmony export */ });
/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-cookie */ "./node_modules/js-cookie/src/js.cookie.js");
/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_cookie__WEBPACK_IMPORTED_MODULE_0__);


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var DISPLAY_SLEEP_TIME = 300;
/**
 * Cookie consent class for handling cookie requests, changes and callbacks
 */

var CookieConsent = /*#__PURE__*/function () {
  /**
   * Creating the cookie consent instance for handling cookie requests, changes and callbacks.
   *
   * Available options:
   *      - prefix: change the prefix for the saved cookies
   *      - callbacks: object with arrays of functions, which are called when a class type has been consented to
   *
   * @param {Object} options
   */
  function CookieConsent() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, CookieConsent);

    this._defaults = {
      prefix: 'ddm-cookie-consent',
      callbacks: {}
    };
    this.debug =  false || "development" === 'development';
    this._options = Object.assign({}, this._defaults, options);

    if (!this._options.prefix.endsWith('-')) {
      this._options.prefix += '-';
    }
  }
  /**
   * Add a callback to given cookie type
   *
   * @param {string} cookieType the cookie type
   * @param {function} callback the callback function to be called when the cookie type has been consented to
   */


  _createClass(CookieConsent, [{
    key: "registerCallback",
    value: function registerCallback(cookieType, callback) {
      var _this = this;

      var array = this._splitString(cookieType);

      array.forEach(function (cookieType) {
        if (!Array.isArray(_this._options.callbacks[cookieType])) {
          _this._options.callbacks[cookieType] = [];
        }

        _this._options.callbacks[cookieType].push(callback);
      });
    }
    /**
     * Remove a callback to given cookie type
     *
     * @param {string} cookieTypes the cookie type
     */

  }, {
    key: "unregisterCallback",
    value: function unregisterCallback(cookieTypes) {
      var _this2 = this;

      var array = this._splitString(cookieTypes);

      array.forEach(function (cookieType) {
        if (_this2._options.callbacks[cookieType]) {
          delete _this2._options.callbacks[cookieType];
        }
      });
    }
  }, {
    key: "_runCallback",
    value: function _runCallback(cookieType) {
      if (this.hasConsent(cookieType) && cookieType in this._options.callbacks && Array.isArray(this._options.callbacks[cookieType])) {
        this._options.callbacks[cookieType].forEach(function (callback) {
          if (typeof callback === 'function') {
            callback();
          }
        });
      }
    }
  }, {
    key: "_runConsentedCallbacks",
    value: function _runConsentedCallbacks() {
      for (var cookieType in this._options.callbacks) {
        if (Object.prototype.hasOwnProperty.call(this._options.callbacks, cookieType)) {
          this._runCallback(cookieType);
        }
      }
    }
    /**
     * Checks whether the cookie type have already been consented to or not.
     *
     * @param cookieTypes the cookie type to check for
     * @returns {boolean} whether the cookie type have been consented to
     */

  }, {
    key: "hasConsent",
    value: function hasConsent(cookieTypes) {
      var _this3 = this;

      var array = this._splitString(cookieTypes);

      var consented = false;
      array.forEach(function (cookieType) {
        var cookie_content = js_cookie__WEBPACK_IMPORTED_MODULE_0___default().get(_this3._options.prefix + cookieType);
        consented = cookie_content === 'true' || cookie_content === true;
      });
      return consented;
    }
    /**
     * Consents to given cookie types.
     *
     * @param cookieType the cookie type to consent to
     */

  }, {
    key: "consent",
    value: function consent(cookieType) {
      this.setConsent(cookieType, true);
    }
    /**
     * Sets the consent for a range of cookie types.
     *
     * @param cookieTypes the cookie types to set
     * @param {boolean, string} value
     */

  }, {
    key: "setConsent",
    value: function setConsent(cookieTypes, value) {
      var _this4 = this;

      var array = this._splitString(cookieTypes);

      array.forEach(function (cookieType) {
        js_cookie__WEBPACK_IMPORTED_MODULE_0___default().set(_this4._options.prefix + cookieType, value === true || value === 'true', {
          expires: 365
        });

        _this4._runCallback(cookieType);
      });
    }
  }, {
    key: "_splitString",
    value: function _splitString(str) {
      return str.split(',');
    }
  }]);

  return CookieConsent;
}();
var CookieModal = /*#__PURE__*/function () {
  /**
   *
   * @param {CookieConsent} instance
   */
  function CookieModal(instance) {
    var _this5 = this;

    _classCallCheck(this, CookieModal);

    this._instance = instance;
    this._cn_bg = document.querySelector('.ddmcn-bg');
    this._cn_checks = this._cn_bg.querySelectorAll('.cookie-types input[type=\"checkbox\"]');

    this._cn_checks_not_checked = function () {
      return _this5._cn_bg.querySelectorAll('.cookie-types input[type=\"checkbox\"]:not(:checked)');
    };

    this._cn_btn_all = document.querySelector('#ddmcn-button-all');
    this._cn_btn_selected = document.querySelector('#ddmcn-button-selected'); // Check all previously checked consents, except the ones which are required anyways

    this._cn_checks_not_checked().forEach(function (check) {
      check.checked = _this5._instance.hasConsent(check.name);
    });

    this._cn_btn_all.addEventListener('click', function (event) {
      event.preventDefault();

      _this5.checkAll();

      _this5._finalize();
    });

    this._cn_btn_selected.addEventListener('click', function (event) {
      event.preventDefault();

      _this5._finalize();
    }); // Show the cookie notice if it hasn't already been interacted with


    if (!this._instance.hasConsent('showed')) {
      this.show();
    }
  }

  _createClass(CookieModal, [{
    key: "show",
    value: function show() {
      var _this6 = this;

      this._cn_bg.style.display = 'block';
      setTimeout(function () {
        _this6._cn_bg.style.opacity = '1';
      }, 10);
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this7 = this;

      this._cn_bg.style.opacity = '0';
      setTimeout(function () {
        _this7._cn_bg.style.display = 'none';
      }, DISPLAY_SLEEP_TIME);
    }
  }, {
    key: "checkAll",
    value: function checkAll() {
      this._cn_checks_not_checked().forEach(function (check) {
        return check.click();
      });
    }
    /**
     * Sets and pushes consent for all checked cookie type checkboxes.
     * @private
     */

  }, {
    key: "_pushSettings",
    value: function _pushSettings() {
      var _this8 = this;

      this._cn_checks.forEach(function (check) {
        if (check.checked) {
          _this8._instance.consent(check.name);
        }
      });

      this._instance.consent('showed');
    }
    /**
     * Finalizes interaction with the cookie notice tool.
     * @private
     */

  }, {
    key: "_finalize",
    value: function _finalize() {
      this._pushSettings();

      setTimeout(this.hide.bind(this), DISPLAY_SLEEP_TIME);
    }
  }]);

  return CookieModal;
}();
var CookieOverlay = /*#__PURE__*/function () {
  /**
   *
   * @param {CookieConsent} instance
   */
  function CookieOverlay(instance) {
    var _this9 = this;

    _classCallCheck(this, CookieOverlay);

    this._instance = instance;
    this._co_bgs = document.querySelectorAll('.ddmco-bg');
    this._co_overlays = {};

    this._co_bgs.forEach(function (overlay) {
      console.log(overlay);
      _this9._co_overlays[overlay.id] = {
        slug: overlay.id,
        cookieTypes: overlay.dataset.types,
        htmlElement: overlay
      };
    }); // for (let overlay in this._co_overlays) {
    //     if (Object.prototype.hasOwnProperty.call(this._co_overlays, overlay)) {
    //         console.log(overlay);
    //
    //         // Don't bother to initialize any further if all cookie types have already been consented to
    //         if (this._instance.hasConsent(overlay.dataset.types)) {
    //             return;
    //         }
    //
    //         console.log(overlay.htmlElement.querySelector('#ddmco-button-accept'));
    //
    //         overlay.htmlElement.querySelector('#ddmco-button-accept').addEventListener('click', (event) => {
    //             event.preventDefault();
    //
    //             this._instance.consent(overlay.cookieTypes);
    //
    //             this.hide(overlay.slug);
    //         });
    //     }
    // }

  }

  _createClass(CookieOverlay, [{
    key: "show",
    value: function show(slug) {
      if (slug in this._co_overlays) {
        var element = this._co_overlays[slug].htmlElement;
        element.style.display = 'block';
        setTimeout(function () {
          element.style.opacity = '1';
        }, 10);
      }
    }
  }, {
    key: "hide",
    value: function hide(slug) {
      if (slug in this._co_overlays) {
        var element = this._co_overlays[slug].htmlElement;
        element.style.opacity = '0';
        setTimeout(function () {
          element.style.display = 'none';
        }, DISPLAY_SLEEP_TIME);
      }
    }
  }]);

  return CookieOverlay;
}();

/***/ }),

/***/ "./resources/js/import.js":
/*!********************************!*\
  !*** ./resources/js/import.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cookie_notice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cookie-notice */ "./resources/js/cookie-notice.js");


var loadCookieNotice = function loadCookieNotice() {
  window.CookieConsent = new _cookie_notice__WEBPACK_IMPORTED_MODULE_0__.CookieConsent();
  window.CookieModal = new _cookie_notice__WEBPACK_IMPORTED_MODULE_0__.CookieModal(window.CookieConsent);
  window.CookieOverlay = new _cookie_notice__WEBPACK_IMPORTED_MODULE_0__.CookieOverlay(window.CookieConsent);
};

if (document.readyState !== "loading") loadCookieNotice();else document.addEventListener("DOMContentLoaded", loadCookieNotice);

/***/ }),

/***/ "./node_modules/js-cookie/src/js.cookie.js":
/*!*************************************************!*\
  !*** ./node_modules/js-cookie/src/js.cookie.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
	var registeredInModuleLoader;
	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		registeredInModuleLoader = true;
	}
	if (true) {
		module.exports = factory();
		registeredInModuleLoader = true;
	}
	if (!registeredInModuleLoader) {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function decode (s) {
		return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
	}

	function init (converter) {
		function api() {}

		function set (key, value, attributes) {
			if (typeof document === 'undefined') {
				return;
			}

			attributes = extend({
				path: '/'
			}, api.defaults, attributes);

			if (typeof attributes.expires === 'number') {
				attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
			}

			// We're using "expires" because "max-age" is not supported by IE
			attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

			try {
				var result = JSON.stringify(value);
				if (/^[\{\[]/.test(result)) {
					value = result;
				}
			} catch (e) {}

			value = converter.write ?
				converter.write(value, key) :
				encodeURIComponent(String(value))
					.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

			key = encodeURIComponent(String(key))
				.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
				.replace(/[\(\)]/g, escape);

			var stringifiedAttributes = '';
			for (var attributeName in attributes) {
				if (!attributes[attributeName]) {
					continue;
				}
				stringifiedAttributes += '; ' + attributeName;
				if (attributes[attributeName] === true) {
					continue;
				}

				// Considers RFC 6265 section 5.2:
				// ...
				// 3.  If the remaining unparsed-attributes contains a %x3B (";")
				//     character:
				// Consume the characters of the unparsed-attributes up to,
				// not including, the first %x3B (";") character.
				// ...
				stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
			}

			return (document.cookie = key + '=' + value + stringifiedAttributes);
		}

		function get (key, json) {
			if (typeof document === 'undefined') {
				return;
			}

			var jar = {};
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all.
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var cookie = parts.slice(1).join('=');

				if (!json && cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = decode(parts[0]);
					cookie = (converter.read || converter)(cookie, name) ||
						decode(cookie);

					if (json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					jar[name] = cookie;

					if (key === name) {
						break;
					}
				} catch (e) {}
			}

			return key ? jar[key] : jar;
		}

		api.set = set;
		api.get = function (key) {
			return get(key, false /* read as raw */);
		};
		api.getJSON = function (key) {
			return get(key, true /* read as json */);
		};
		api.remove = function (key, attributes) {
			set(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.defaults = {};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./resources/js/cookie-notice.js");
/******/ 	__webpack_require__("./resources/js/import.js");
/******/ })()
;
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/cookie-consent.js":
/*!****************************************!*\
  !*** ./resources/js/cookie-consent.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CookieConsent": function() { return /* binding */ CookieConsent; }
/* harmony export */ });
/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-cookie */ "./node_modules/js-cookie/src/js.cookie.js");
/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_cookie__WEBPACK_IMPORTED_MODULE_0__);


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


/**
 * Class for handling cookie requests, changes and callbacks
 */

var CookieConsent = /*#__PURE__*/function () {
  /**
   * Creates the instance for handling cookie requests, changes and callbacks.
   *
   * Available options:
   *      - prefix: change the prefix for the saved cookies (WIP)
   *      - callbacks: object with arrays of functions, which are called when a cookie class has been consented to
   *
   * @param {Object} options
   */
  function CookieConsent() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, CookieConsent);

    this._defaults = {
      // prefix: 'ddm-cookie-consent', TODO: Find a way to set prefix and let antlers tag know about it
      callbacks: {}
    }; // this.debug = (!process.env.NODE_ENV || process.env.NODE_ENV === 'development');

    this._options = Object.assign({}, this._defaults, options);
    this._options.prefix = 'ddm-cookie-consent'; // Add trailing dash if none exists

    if (!this._options.prefix.endsWith('-')) {
      this._options.prefix += '-';
    }
  }
  /**
   * Adds a callback function to a cookie class or a list of cookie classes.
   *
   * @param {string} cookieClasses the cookie classes
   * @param {function} callback the callback function to be called when the cookie classes have been consented to
   */


  _createClass(CookieConsent, [{
    key: "registerCallback",
    value: function registerCallback(cookieClasses, callback) {
      var _this = this;

      this._runSplitList(cookieClasses, function (cookieClass) {
        // Create callback array if it doesn't exist already
        if (!Array.isArray(_this._options.callbacks[cookieClass])) {
          _this._options.callbacks[cookieClass] = [];
        }

        _this._options.callbacks[cookieClass].push(callback);
      });
    }
    /**
     * Removes the callbacks added to a cookie class or a list of cookie classes.
     *
     * @param {string} cookieClasses the cookie classes
     */

  }, {
    key: "unregisterCallback",
    value: function unregisterCallback(cookieClasses) {
      var _this2 = this;

      this._runSplitList(cookieClasses, function (cookieClass) {
        // Deletes the callback entry if it exists
        if (_this2._options.callbacks[cookieClass]) {
          delete _this2._options.callbacks[cookieClass];
        }
      });
    }
    /**
     * Runs the callback function of a cookie class if it has been consented to.
     *
     * @param {string} cookieClass the cookie classes
     */

  }, {
    key: "runCallback",
    value: function runCallback(cookieClass) {
      if (this.hasConsent(cookieClass)) {
        // check whether the cookie class has callback functions
        if (cookieClass in this._options.callbacks) {
          this._options.callbacks[cookieClass].forEach(function (callback) {
            if (typeof callback === 'function') {
              callback();
            }
          });
        }
      }
    }
    /**
     * Runs all the callback functions which cookie classes have been consented to.
     */

  }, {
    key: "runCallbacks",
    value: function runCallbacks() {
      for (var cookieClass in this._options.callbacks) {
        if (this._options.callbacks.hasOwnProperty(cookieClass)) {
          this.runCallback(cookieClass);
        }
      }
    }
    /**
     * Checks whether the cookie class or cookie classes have already been consented to.
     *
     * @param cookieClasses the cookie classes to check for
     * @returns {boolean} whether the cookie classes have been consented to
     */

  }, {
    key: "hasConsent",
    value: function hasConsent(cookieClasses) {
      var _this3 = this;

      var consent = false;

      this._runSplitList(cookieClasses, function (cookieClass) {
        consent = js_cookie__WEBPACK_IMPORTED_MODULE_0___default().get(_this3._options.prefix + cookieClass) === 'true';
      });

      return consent;
    }
    /**
     * Consents to the cookie class.
     *
     * @param cookieClass the cookie class to consent to
     */

  }, {
    key: "consent",
    value: function consent(cookieClass) {
      this.setConsent(cookieClass, true);
    }
    /**
     * Sets the consent for a list of cookie classes.
     *
     * @param cookieClasses the cookie classes to set
     * @param {boolean, string} value
     */

  }, {
    key: "setConsent",
    value: function setConsent(cookieClasses, value) {
      var _this4 = this;

      this._runSplitList(cookieClasses, function (cookieType) {
        js_cookie__WEBPACK_IMPORTED_MODULE_0___default().set(_this4._options.prefix + cookieType, value === true || value === 'true', {
          expires: 365
        });

        _this4.runCallback(cookieType);
      });
    }
    /**
     * Runs a function on a comma-seperated list of strings.
     *
     * @param {string} str the comma-seperated list
     * @param {function} func the function to iterate over
     * @private
     */

  }, {
    key: "_runSplitList",
    value: function _runSplitList(str, func) {
      // First split the string into pieces
      var arr = str.toString().split(',');
      arr.forEach(func);
    }
  }]);

  return CookieConsent;
}();

/***/ }),

/***/ "./resources/js/cookie-cover.js":
/*!**************************************!*\
  !*** ./resources/js/cookie-cover.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CookieCover": function() { return /* binding */ CookieCover; }
/* harmony export */ });
/* harmony import */ var _cookie_consent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cookie-consent */ "./resources/js/cookie-consent.js");


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var DISPLAY_SLEEP_TIME = 300;
/**
 * Class for initializing the cookie covers on the current page.
 */

var CookieCover = /*#__PURE__*/function () {
  /**
   *
   * @param {CookieConsent} instance
   */
  function CookieCover(instance) {
    _classCallCheck(this, CookieCover);

    this._instance = instance;
    this._covers = document.querySelectorAll('.ddmcc'); // Stop execution if there were no cookie covers found in html

    if (this._covers.length === 0) {
      return;
    } // Create


    this._covers.forEach(function (cover) {// Don't bother to initialize any further if all cookie types have already been consented to
    }); // for (let overlay in this._co_overlays) {
    //     if (Object.prototype.hasOwnProperty.call(this._co_overlays, overlay)) {
    //         console.log(overlay);
    //
    //         // Don't bother to initialize any further if all cookie types have already been consented to
    //         if (this._instance.hasConsent(overlay.dataset.types)) {
    //             return;
    //         }
    //
    //         console.log(overlay.htmlElement.querySelector('#ddmco-button-accept'));
    //
    //         overlay.htmlElement.querySelector('#ddmco-button-accept').addEventListener('click', (event) => {
    //             event.preventDefault();
    //
    //             this._instance.consent(overlay.cookieTypes);
    //
    //             this.hide(overlay.slug);
    //         });
    //     }
    // }

  }
  /**
   * Returns the first cookie cover with a given handle.
   *
   * @param {string} handle
   * @returns {Element} the node element
   */


  _createClass(CookieCover, [{
    key: "getCoverByHandle",
    value: function getCoverByHandle(handle) {
      return document.querySelector('.ddmcc#' + handle);
    }
  }, {
    key: "show",
    value: function show(slug) {
      if (slug in this._covers) {
        var element = this._covers[slug].htmlElement;
        element.style.display = 'block';
        setTimeout(function () {
          element.style.opacity = '1';
        }, 10);
      }
    }
  }, {
    key: "hide",
    value: function hide(slug) {
      if (slug in this._covers) {
        var element = this._covers[slug].htmlElement;
        element.style.opacity = '0';
        setTimeout(function () {
          element.style.display = 'none';
        }, DISPLAY_SLEEP_TIME);
      }
    }
  }]);

  return CookieCover;
}();

/***/ }),

/***/ "./resources/js/cookie-modal.js":
/*!**************************************!*\
  !*** ./resources/js/cookie-modal.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CookieModal": function() { return /* binding */ CookieModal; }
/* harmony export */ });
/* harmony import */ var _cookie_consent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cookie-consent */ "./resources/js/cookie-consent.js");


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var DISPLAY_SLEEP_TIME = 300;
/**
 * Class for initializing the cookie modal and its actions.
 */

var CookieModal = /*#__PURE__*/function () {
  /**
   * Initializes the cookie modal if it is found on the page.
   *
   * @param {CookieConsent} instance the CookieConsent instance
   */
  function CookieModal(instance) {
    var _this = this;

    _classCallCheck(this, CookieModal);

    this._instance = instance; // As there should only be one cookie modal we query only the first in the DOM

    this._modal = document.querySelector('.ddmcm'); // Query all cookie class checkboxes and stop initialization if there are none

    this._modal_checks = this._modal.querySelectorAll('.ddmcm-classes input[type=\"checkbox\"]');

    this._modal_unchecked_checks = function () {
      return _this._modal.querySelectorAll('.ddmcm-classes input[type=\"checkbox\"]:not(:checked)');
    };

    if (this._modal_checks.length === 0) {
      return;
    } // Check all previously checked checkboxes, except the ones which are checked already


    this._modal_unchecked_checks().forEach(function (check) {
      check.checked = _this._instance.hasConsent(check.name);
    }); // Query the two buttons and stop initialization if they aren't present


    this._modal_button_all = this._modal.querySelector('#ddmcm-button-all');
    this._modal_button_selected = this._modal.querySelector('#ddmcm-button-selected');

    if (!document.body.contains(this._modal_button_all) && !document.body.contains(this._modal_button_selected)) {
      return;
    }

    this._modal_button_all.addEventListener('click', function (event) {
      event.preventDefault();

      _this.checkAll();

      _this._finalize();
    });

    this._modal_button_selected.addEventListener('click', function (event) {
      event.preventDefault();

      _this._finalize();
    }); // Show the cookie notice if it hasn't already been interacted with


    if (!this._instance.hasConsent('showed')) {
      this.show();
    }
  }
  /**
   * Shows the cookie modal.
   */


  _createClass(CookieModal, [{
    key: "show",
    value: function show() {
      var _this2 = this;

      this._modal.style.display = 'block';
      setTimeout(function () {
        _this2._modal.style.opacity = '1';
      }, 10);
    }
    /**
     * Hides the cookie modal.
     */

  }, {
    key: "hide",
    value: function hide() {
      var _this3 = this;

      this._modal.style.opacity = '0';
      setTimeout(function () {
        _this3._modal.style.display = 'none';
      }, DISPLAY_SLEEP_TIME);
    }
    /**
     * Checks all the cookie class checkboxes.
     */

  }, {
    key: "checkAll",
    value: function checkAll() {
      this._modal_unchecked_checks().forEach(function (check) {
        return check.click();
      });
    }
    /**
     * Consents for all checked cookie class checkboxes.
     * @private
     */

  }, {
    key: "_pushSettings",
    value: function _pushSettings() {
      var _this4 = this;

      this._modal_checks.forEach(function (check) {
        if (check.checked) {
          _this4._instance.consent(check.name);
        }
      });

      this._instance.consent('showed');
    }
    /**
     * Consents for all checked cookie class checkboxes and hides the cookie modal.
     * @private
     */

  }, {
    key: "_finalize",
    value: function _finalize() {
      this._pushSettings();

      setTimeout(this.hide.bind(this), DISPLAY_SLEEP_TIME);
    }
  }]);

  return CookieModal;
}();

/***/ }),

/***/ "./resources/js/export.js":
/*!********************************!*\
  !*** ./resources/js/export.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cookie_consent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cookie-consent */ "./resources/js/cookie-consent.js");
/* harmony import */ var _cookie_modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cookie-modal */ "./resources/js/cookie-modal.js");
/* harmony import */ var _cookie_cover__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cookie-cover */ "./resources/js/cookie-cover.js");



window.CookieConsent = new _cookie_consent__WEBPACK_IMPORTED_MODULE_0__.CookieConsent();
window.CookieModal = new _cookie_modal__WEBPACK_IMPORTED_MODULE_1__.CookieModal(window.CookieConsent);
window.CookieCover = new _cookie_cover__WEBPACK_IMPORTED_MODULE_2__.CookieCover(window.CookieConsent);

/***/ }),

/***/ "./node_modules/js-cookie/src/js.cookie.js":
/*!*************************************************!*\
  !*** ./node_modules/js-cookie/src/js.cookie.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
	var registeredInModuleLoader;
	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		registeredInModuleLoader = true;
	}
	if (true) {
		module.exports = factory();
		registeredInModuleLoader = true;
	}
	if (!registeredInModuleLoader) {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function decode (s) {
		return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
	}

	function init (converter) {
		function api() {}

		function set (key, value, attributes) {
			if (typeof document === 'undefined') {
				return;
			}

			attributes = extend({
				path: '/'
			}, api.defaults, attributes);

			if (typeof attributes.expires === 'number') {
				attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
			}

			// We're using "expires" because "max-age" is not supported by IE
			attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

			try {
				var result = JSON.stringify(value);
				if (/^[\{\[]/.test(result)) {
					value = result;
				}
			} catch (e) {}

			value = converter.write ?
				converter.write(value, key) :
				encodeURIComponent(String(value))
					.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

			key = encodeURIComponent(String(key))
				.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
				.replace(/[\(\)]/g, escape);

			var stringifiedAttributes = '';
			for (var attributeName in attributes) {
				if (!attributes[attributeName]) {
					continue;
				}
				stringifiedAttributes += '; ' + attributeName;
				if (attributes[attributeName] === true) {
					continue;
				}

				// Considers RFC 6265 section 5.2:
				// ...
				// 3.  If the remaining unparsed-attributes contains a %x3B (";")
				//     character:
				// Consume the characters of the unparsed-attributes up to,
				// not including, the first %x3B (";") character.
				// ...
				stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
			}

			return (document.cookie = key + '=' + value + stringifiedAttributes);
		}

		function get (key, json) {
			if (typeof document === 'undefined') {
				return;
			}

			var jar = {};
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all.
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var cookie = parts.slice(1).join('=');

				if (!json && cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = decode(parts[0]);
					cookie = (converter.read || converter)(cookie, name) ||
						decode(cookie);

					if (json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					jar[name] = cookie;

					if (key === name) {
						break;
					}
				} catch (e) {}
			}

			return key ? jar[key] : jar;
		}

		api.set = set;
		api.get = function (key) {
			return get(key, false /* read as raw */);
		};
		api.getJSON = function (key) {
			return get(key, true /* read as json */);
		};
		api.remove = function (key, attributes) {
			set(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.defaults = {};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./resources/js/export.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;